Neste capítulo, apresentamos as três versões do código desenvolvidas para fins comparativos: uma versão serial, uma versão paralelizada utilizando OpenMP e uma versão implementada em CUDA. Cada uma dessas versões será explicada em detalhes nas subseções a seguir.

\subsection{Versão Serial}

    A versão serial do código, localizada no arquivo \texttt{serial.cpp}, foi implementada como ponto de partida para o desenvolvimento das versões paralelas. Nesta implementação, o algoritmo é executado de forma sequencial, processando os dados de entrada um elemento por vez. Essa abordagem é simples e direta, mas não aproveita os recursos de paralelismo disponíveis em arquiteturas modernas.

    O código foi estruturado para ser claro e modular, facilitando a compreensão e a posterior paralelização. Ele realiza as seguintes etapas principais:
    \begin{itemize}
        \item Leitura dos dados de entrada.
        \item Processamento sequencial dos dados, aplicando a técnica de meios-tons utilizando difusão de erro.
        \item Escrita dos resultados no arquivo de saída.
    \end{itemize}

    O algoritmo de difusão de erro utilizado na versão serial é configurado para suportar diferentes métodos de dithering, como Floyd-Steinberg, Burkes, Sierra, entre outros. A escolha do método é feita com base em um parâmetro de entrada, permitindo flexibilidade na execução.

    Essa versão serve como base para medir o desempenho inicial e comparar os ganhos obtidos com as versões paralelas. O código completo da implementação pode ser encontrado abaixo:

\subsection{Versão Paralela com OpenMP}

    A versão paralela utilizando OpenMP foi desenvolvida a partir da versão serial, com o objetivo de explorar o paralelismo em CPUs multicore. O código-fonte desta versão é essencialmente o mesmo da versão serial, diferindo apenas pela inclusão de diretivas de paralelização do OpenMP, que são ativadas em tempo de compilação. Os resultados e o impacto dessas alterações serão discutidos na \autoref{sec:speedup}.

\subsection{Versão em CUDA}

    A versão em CUDA, que será implementada no futuro, tem como objetivo explorar o paralelismo massivo oferecido por GPUs. Esta subseção será preenchida com os detalhes da implementação assim que o código estiver concluído.

    \vspace{2cm} % Espaço em branco para a futura explicação da versão CUDA.


\subsection{Implementação de Métodos Estocásticos}

    Além das versões mencionadas anteriormente, também foram implementados métodos estocásticos para avaliar como o uso de aleatoriedade pode impactar o resultado visual da técnica de meios-tons. Esses métodos introduzem variações aleatórias no processo de difusão de erro, com o objetivo de verificar se a qualidade visual das imagens processadas é significativamente alterada.

    A implementação dos métodos estocásticos foi realizada adicionando um fator de ruído controlado ao cálculo da difusão de erro. Esse fator é gerado utilizando uma distribuição uniforme, garantindo que o comportamento do algoritmo permaneça previsível e reprodutível. As etapas principais dessa abordagem são as seguintes:
    \begin{itemize}
        \item Geração de um valor aleatório para cada pixel, dentro de um intervalo predefinido.
        \item Ajuste do erro difundido com base no valor aleatório gerado.
        \item Continuação do processamento com o erro ajustado.
    \end{itemize}

    Para as versões paralelas, foram adicionadas flags específicas para habilitar o suporte aos métodos estocásticos:
    \begin{itemize}
        \item Na versão OpenMP, a flag \texttt{-stochastic} foi utilizada durante a compilação para ativar o código relacionado aos métodos estocásticos. O comportamento estocástico pode ser controlado por um parâmetro de entrada, permitindo escolher entre dithering estocástico (1) ou padrão (0), sendo o padrão o valor 1.
        \item Na versão CUDA, a flag \texttt{-stochastic} também foi empregada, garantindo que o comportamento estocástico fosse incorporado ao kernel CUDA. Assim como na versão OpenMP, o parâmetro de entrada permite alternar entre dithering estocástico (1) ou padrão (0), com o valor padrão definido como 1.
    \end{itemize}

    Apesar de introduzir aleatoriedade no processo, os resultados preliminares indicam que o impacto visual é mínimo, especialmente em imagens com alta resolução. Isso sugere que os métodos estocásticos podem ser uma alternativa viável para cenários onde a uniformidade do padrão de dithering não é uma prioridade.

    A análise detalhada dos resultados obtidos com os métodos estocásticos será apresentada na \autoref{sec:speedup}, onde compararemos a qualidade visual e o desempenho em relação às outras versões do código.


    \subsection{Análise de WSNR}

        Para avaliar a qualidade das imagens processadas pelas diferentes versões do código, utilizamos o script \texttt{wsnr.py}, que calcula a métrica WSNR (Weighted Signal-to-Noise Ratio). Essa métrica é amplamente utilizada para medir a qualidade de imagens processadas, levando em consideração o ruído introduzido durante o processamento.

        A seguir, apresentamos os resultados obtidos para cada método (serial, OpenMP e CUDA), organizados por tamanho de imagem:

        \subsubsection*{Tabela de Resultados WSNR por Método e Tamanho de Imagem}

        \begin{table}[H]
            \centering
            \begin{tabular}{|c|c|c|c|c|}
                \hline
                \textbf{Tamanho} & \textbf{Imagem} & \textbf{CUDA (dB)} & \textbf{OpenMP (dB)} & \textbf{Serial (dB)} \\ \hline
                \multirow{2}{*}{Small} 
                & small\_1 & 0.6595 & -0.1043 & -0.1279 \\ \cline{2-5}
                & small\_2 & 1.1523 & 0.6237 & 0.5631 \\ \hline
                \multirow{8}{*}{Medium} 
                & medium\_1 & 1.2968 & 0.8956 & 0.9051 \\ \cline{2-5}
                & medium\_2 & 1.2322 & 0.9434 & 0.8777 \\ \cline{2-5}
                & medium\_3 & 0.6089 & 0.2502 & 0.2566 \\ \cline{2-5}
                & medium\_4 & 0.7146 & 0.3194 & 0.2924 \\ \cline{2-5}
                & medium\_5 & 1.7778 & 0.7717 & 0.7879 \\ \cline{2-5}
                & medium\_6 & 1.3159 & 0.8904 & 0.8921 \\ \cline{2-5}
                & medium\_7 & 1.2963 & 0.7031 & 0.6980 \\ \cline{2-5}
                & medium\_8 & -0.2986 & -0.8768 & -0.8693 \\ \hline
                \multirow{5}{*}{Large} 
                & large\_1 & 0.0847 & -0.0862 & -0.0905 \\ \cline{2-5}
                & large\_2 & 1.6083 & 0.8550 & 0.8642 \\ \cline{2-5}
                & large\_3 & 1.6087 & 0.8773 & 0.8754 \\ \cline{2-5}
                & large\_4 & 0.7675 & 0.7062 & 0.6588 \\ \cline{2-5}
                & large\_5 & -0.3377 & -0.8666 & -0.8857 \\ \hline
                \multirow{7}{*}{Xlarge} 
                & xlarge\_1 & 1.6322 & 0.8531 & 0.8586 \\ \cline{2-5}
                & xlarge\_2 & 1.6904 & 0.9132 & 0.9014 \\ \cline{2-5}
                & xlarge\_3 & 1.6817 & 0.8648 & 0.8632 \\ \cline{2-5}
                & xlarge\_4 & 1.6876 & 0.9090 & 0.9010 \\ \cline{2-5}
                & xlarge\_5 & 0.7856 & 0.4889 & 0.4997 \\ \cline{2-5}
                & xlarge\_6 & 2.3256 & 1.3715 & 1.3500 \\ \cline{2-5}
                & xlarge\_7 & 0.8412 & 0.1943 & 0.2099 \\ \hline
                \multicolumn{2}{|c|}{\textbf{Média WSNR}} & \textbf{1.0969} & \textbf{0.5226} & \textbf{0.5128} \\ \hline
            \end{tabular}
            \caption{Resultados WSNR por Método e Tamanho de Imagem}
        \end{table}
        \subsubsection*{Interpretação dos Resultados}
        A métrica WSNR indica a relação entre o sinal e o ruído introduzido no processamento das imagens. Valores mais altos de WSNR indicam menor degradação da qualidade da imagem. Observa-se que a versão CUDA apresenta a maior média de WSNR (1.0969 dB), seguida pela versão OpenMP (0.5226 dB) e pela versão serial (0.5128 dB). Isso sugere que a versão CUDA não apenas é mais eficiente em termos de desempenho, mas também preserva melhor a qualidade das imagens processadas.