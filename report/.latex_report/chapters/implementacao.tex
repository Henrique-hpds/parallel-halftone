Neste capítulo, apresentamos as três versões do código desenvolvidas para fins comparativos: uma versão serial, uma versão paralelizada utilizando OpenMP e uma versão implementada em CUDA. Cada uma dessas versões será explicada em detalhes nas subseções a seguir.

\subsection{Versão Serial}

    A versão serial do código, localizada no arquivo \texttt{serial.cpp}, foi implementada como ponto de partida para o desenvolvimento das versões paralelas. Nesta implementação, o algoritmo é executado de forma sequencial, processando os dados de entrada um elemento por vez. Essa abordagem é simples e direta, mas não aproveita os recursos de paralelismo disponíveis em arquiteturas modernas. A figura \ref{fig:serial_print} ilustra a função principal de difusão de erro na versão serial, onde cada pixel é processado individualmente, aplicando a técnica de meios-tons com base no erro de quantização.

    \begin{figure}[H]
        \centering
        \includegraphics[width=0.9\textwidth]{figures/serial_print.png}
        \caption{Função principal de difusão de erro na versão serial.}
        \label{fig:serial_print}
    \end{figure}

    O código foi estruturado para ser claro e modular, facilitando a compreensão e a posterior paralelização. Ele realiza as seguintes etapas principais:
    \begin{itemize}
        \item Leitura dos dados de entrada.
        \item Processamento sequencial dos dados, aplicando a técnica de meios-tons utilizando difusão de erro.
        \item Escrita dos resultados no arquivo de saída.
    \end{itemize}

    O algoritmo de difusão de erro utilizado na versão serial é configurado para suportar todos os métodos descritos na~\autoref{subsec:half:err_dif}. A escolha do método é feita com base em um parâmetro de entrada, permitindo flexibilidade na execução. Essa versão serve como base para medir o desempenho inicial e comparar os ganhos obtidos com as versões paralelas.

\subsection{Versão Paralela com OpenMP}

    A versão paralela utilizando OpenMP, implementada no arquivo \texttt{omp.cpp}, foi desenvolvida a partir da versão serial com o objetivo de explorar o paralelismo disponível em CPUs multicore. Nesta implementação, o processamento dos pixels é realizado de forma concorrente, utilizando diretivas OpenMP para paralelizar os principais laços do algoritmo. Isso permite uma redução significativa no tempo de execução, especialmente para imagens de maior resolução.

    O código mantém a estrutura modular da versão serial, facilitando a manutenção e a comparação entre as abordagens. Além disso, a versão OpenMP suporta tanto o processamento de imagens em escala de cinza quanto coloridas, aplicando a difusão de erro separadamente em cada canal de cor. A figura \ref{fig:omp_print} ilustra a função principal de difusão de erro na versão OpenMP.


    \begin{figure}[H]
        \centering
        \includegraphics[width=0.9\textwidth]{figures/omp_print.png}
        \caption{Função principal de difusão de erro na versão OpenMP.}
        \label{fig:omp_print}
    \end{figure}

    Novamente, o modo de difusão pode ser selecionado por meio dos parâmetros de entrada. O desempenho e o impacto visual da versão OpenMP são discutidos em detalhes na \autoref{sec:speedup}.

\subsection{Versão em CUDA}

    A versão CUDA, implementada no arquivo \texttt{cuda.cu}, foi desenvolvida para explorar o paralelismo massivo oferecido por GPUs. Assim como nas versões anteriores, o código é capaz de processar imagens em escala de cinza ou coloridas, aplicando a difusão de erro separadamente em cada canal de cor.

    Nesta implementação, o processamento dos pixels é realizado de forma paralela ao longo das diagonais da imagem, garantindo que a propagação do erro respeite as dependências espaciais do algoritmo. Cada thread da GPU é responsável por processar um pixel em uma determinada diagonal, e a difusão do erro para os vizinhos é feita utilizando operações atômicas para evitar condições de corrida.

    As principais etapas da versão CUDA são:
    \begin{itemize}
        \item Leitura dos dados de entrada e transferência da imagem para a memória da GPU.
        \item Processamento paralelo dos pixels ao longo das diagonais, aplicando a técnica de meios-tons com difusão de erro.
        \item Transferência dos resultados da GPU de volta para a memória do host.
        \item Escrita dos resultados no arquivo de saída.
    \end{itemize}

    As \autoref{fig:cuda_print1} e \ref{fig:cuda_print2} mostram, respectivamente, o \textit{kernel} de processamento de diagonais e a função principal de difusão de erro na versão CUDA.

    \begin{figure}[H]
        \centering
        \includegraphics[width=0.9\textwidth]{figures/cuda_print1.png}
        \caption{Função principal de difusão de erro na versão CUDA.}
        \label{fig:cuda_print1}
    \end{figure}

    \begin{figure}[H]
        \centering
        \includegraphics[width=0.9\textwidth]{figures/cuda_print2.png}
        \caption{Função principal de difusão de erro na versão CUDA.}
        \label{fig:cuda_print2}
    \end{figure}


    O método de difusão de erro utilizado pode ser selecionado por parâmetro de entrada, assim como nas demais versões. O desempenho e a qualidade visual dos resultados obtidos com a versão CUDA são discutidos na \autoref{sec:speedup}.


\subsection{Implementação de Métodos Estocásticos}

    Além das versões mencionadas anteriormente, também foram implementados métodos estocásticos para avaliar como o uso de aleatoriedade pode impactar o resultado visual da técnica de meios-tons. Esses métodos introduzem variações aleatórias no processo de difusão de erro, com o objetivo de verificar se a qualidade visual das imagens processadas é significativamente alterada.

    A implementação dos métodos estocásticos foi realizada adicionando um fator de ruído controlado ao cálculo da difusão de erro. Esse fator é gerado utilizando uma distribuição uniforme, garantindo que o comportamento do algoritmo permaneça previsível e reprodutível. As etapas principais dessa abordagem são as seguintes:
    \begin{itemize}
        \item Geração de um valor aleatório para cada pixel, dentro de um intervalo predefinido.
        \item Ajuste do erro difundido com base no valor aleatório gerado.
        \item Continuação do processamento com o erro ajustado.
    \end{itemize}

    Para as versões paralelas, foram adicionadas flags específicas para habilitar o suporte aos métodos estocásticos:
    \begin{itemize}
        \item Na versão OpenMP, a flag \texttt{-stochastic} foi utilizada durante a compilação para ativar o código relacionado aos métodos estocásticos. O comportamento estocástico pode ser controlado por um parâmetro de entrada, permitindo escolher entre dithering estocástico (1) ou padrão (0), sendo o padrão o valor 1.
        \item Na versão CUDA, a flag \texttt{-stochastic} também foi empregada, garantindo que o comportamento estocástico fosse incorporado ao kernel CUDA. Assim como na versão OpenMP, o parâmetro de entrada permite alternar entre dithering estocástico (1) ou padrão (0), com o valor padrão definido como 1.
    \end{itemize}

    Apesar de introduzir aleatoriedade no processo, os resultados preliminares indicam que o impacto visual é mínimo, especialmente em imagens com alta resolução. Isso sugere que os métodos estocásticos podem ser uma alternativa viável para cenários onde a uniformidade do padrão de dithering não é uma prioridade.

    A análise detalhada dos resultados obtidos com os métodos estocásticos será apresentada na \autoref{sec:speedup}, onde compararemos a qualidade visual e o desempenho em relação às outras versões do código.


 